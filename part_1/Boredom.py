"""
由对命题特性的分析可知：
1.只要全流程中有操作删除ak，那就要把ak要全部删除干净(cnt[ak]次操作)
2.只要全流程涉及了删除ak的操作，就意味着全流程没有删除ak-1或ak+1的操作
3.如果全流程中不涉及删除ak的操作，又分两种情况：
①删除了ak-1
②没删除ak-1（那就是删除了ak+1,但是由于我们按顺序递归，这里不从后往前考虑）
所以：
显然，对这个数列的操作与这个数列的排序是无关的，我们使用哈希表的方式统计
每个元素出现的次数，记为cnt[x].
现在我们做一个二维dp表，dp[i][0],dp[i][1]分别表示不删去i、删去i时
得分的最大值。
于是我们得到了一个递归的dp！
状态转移方程为：
dp[i][1]=dp[i-1][0]+i*cnt[i]
dp[i][0]=max(dp[i-1][0],dp[i-1][1])
边界条件：
dp[0][0]和dp[0][1]
"""
input()
c = [0] * 100001
for m in map(int, input().split()):
    c[m] += 1

dp = [0] * 100001
for i in range(1, 100001):
    dp[i] = max(dp[i - 1], dp[i - 2] + i * c[i])

print(max(dp))